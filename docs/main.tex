\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazilian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[margin=2.5cm]{geometry}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{array}
\usepackage[hidelinks]{hyperref}
\usepackage{multirow}

\setlength{\parskip}{3pt}

% Configuração do listings para código C
\lstset{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numberstyle=\tiny\color{gray},
    numbers=left,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    frame=single,
    rulecolor=\color{black!30},
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    escapeinside={(*@}{@*)},
    morekeywords={pragma, omp, parallel, for, taskloop, taskgroup, task, depend, shared, firstprivate, default, none, grainsize}
}

\title{Trabalho Prático: Implementação e Análise \\
TCP vs. TLS}
\author{Manoel Silva, Daniel Arruda}
\date{}

\begin{document}

\maketitle

\begin{abstract}
Este trabalho apresenta um estudo comparativo entre transmissões de arquivos utilizando conexões TCP convencionais e conexões seguras com TLS (Transport Layer Security). Foi desenvolvido um sistema cliente-servidor em Python capaz de transmitir arquivos de texto através de ambos os protocolos. Os experimentos incluem capturas de pacotes de rede utilizando Wireshark, permitindo análise detalhada das diferenças entre comunicação em texto plano e comunicação criptografada. Os resultados demonstram o overhead introduzido pelo TLS em termos de tamanho de pacotes e tempo de transmissão, enquanto evidenciam os ganhos significativos em segurança e confidencialidade dos dados transmitidos.
\end{abstract}

\section{Introdução}

A segurança na transmissão de dados tornou-se um requisito fundamental em aplicações modernas de rede. Com o crescimento exponencial de ameaças cibernéticas e interceptações maliciosas, a proteção de informações durante o tráfego em redes públicas é essencial para garantir confidencialidade, integridade e autenticidade dos dados.

O protocolo TCP (Transmission Control Protocol) fornece comunicação confiável entre sistemas, garantindo entrega ordenada de pacotes e controle de fluxo. Entretanto, TCP por si só não oferece nenhuma forma de criptografia, transmitindo dados em texto plano e tornando-os vulneráveis a ataques de interceptação (man-in-the-middle) e espionagem.

O TLS (Transport Layer Security), sucessor do SSL (Secure Sockets Layer), é um protocolo criptográfico projetado para fornecer comunicação segura sobre redes de computadores. TLS opera sobre TCP, adicionando camadas de segurança através de criptografia, autenticação de endpoints e verificação de integridade de mensagens.

Este trabalho tem como objetivo implementar e comparar sistemas de transmissão de arquivos utilizando TCP puro e TCP com TLS, analisando aspectos de segurança, performance e overhead introduzido pela camada de criptografia.

\section{Transport Control Protocol}

O TCP (Transmission Control Protocol) é um protocolo da camada de transporte responsável por fornecer comunicação confiável entre dois hosts. Ele estabelece uma conexão antes que qualquer dado seja transmitido, utilizando o processo conhecido como three-way handshake.

Nesse procedimento, o cliente envia um segmento SYN, o servidor responde com SYN-ACK, e o cliente finaliza com ACK, formando assim um canal lógico entre as partes.

Após estabelecida a conexão, o TCP garante que os dados sejam entregues de forma ordenada, sem perdas e sem duplicações, utilizando mecanismos como numeração de bytes, confirmações de recebimento (ACKs) e retransmissões em caso de falhas. O protocolo também controla o fluxo e a congestão da rede, ajustando dinamicamente a taxa de envio para evitar sobrecargas e garantir desempenho estável. 

Por fim, a conexão é encerrada mediante outro processo de troca de sinais, geralmente envolvendo quatro mensagens (FIN e ACK), garantindo que ambos os lados encerrem a comunicação de forma coordenada.

Contudo, tal protocolo não garante a segurança dos dados trafegados, sendo esta uma comunicação em texto plano. Por conta disso, o TLS foi introduzido para garantir a confidencialidade e a segurança do tráfego desses dados pela rede.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{plaintext1.png}
    \caption{Texto Plano TCP do Cliente}
    \label{fig:plaintext1}
    \centering
    \includegraphics[width=0.7\linewidth]{plaintext2.png}
    \caption{Texto Plano TCP do Servidor}
    \label{fig:plaintext2}
\end{figure}

\section{Transport Layer Security}

Diferente o TCP, o TLS (Transport Layer Security) é um protocolo utilizado para prover segurança na comunicação entre cliente e servidor, operando sobre o TCP. Embora resida tecnicamente na camada de aplicação, do ponto de vista do desenvolvedor, ele é um protocolo na camada de transporte.

Seu funcionamento se divide em duas etapas principais: o handshake e a criptografia dos dados transmitidos.

O handshake TLS é a sequência de mensagens que estabelece parâmetros de segurança entre cliente e servidor antes da transmissão de dados de aplicação. Seu objetivo é: (1) autenticar o servidor (e opcionalmente o cliente), (2) negociar algoritmos (cipher suite), (3) estabelecer segredos compartilhados (chaves de sessão) e (4) verificar que ambas as partes possuem os mesmos segredos (mensagens \texttt{Finished}). Após o handshake, o Record Protocol protege qualquer \texttt{application\_data} por cifragem autenticada (AEAD) ou por combinação MAC+cifra dependendo da versão.

\subsection{Funcionamento do Handshake TLS}
O processo pode ser dividido em três fases principais.

\subsubsection{Fase 1: \textit{ClientHello} e \textit{ServerHello}}

Nesta fase, cliente e servidor negociam os parâmetros iniciais da conexão segura.

\paragraph*{ClientHello}
O processo inicia quando o cliente envia o \textit{ClientHello}, contendo:

\begin{itemize}
    \item versões suportadas do TLS;
    \item lista de \textit{Cipher Suites}, que representam combinações de algoritmos criptográficos (como troca de chaves, cifra simétrica e função de integridade) que definem como a comunicação será protegida durante a sessão TLS;
    \item \textit{Client Random}, um valor aleatório enviado pelo cliente usado, junto com outros valores, para derivar as chaves criptográficas da sessão;
    \item extensão \textbf{KeyShare} com parâmetros ECDHE(Elliptic Curve Diffie–Hellman Ephemeral), ou seja, com um método de troca de chaves que usa curvas elípticas e chaves temporárias para permitir que duas partes gerem um segredo compartilhado com alta segurança e suporte a forward secrecy;
    \item extensão \textbf{SNI} (Server Name Indication).
\end{itemize}

No TLS~1.2 o \textit{ClientHello} não incluía o \textbf{KeyShare}. Em vez disso, a troca de chaves era adiada para mensagens posteriores, como o \textit{ServerKeyExchange} e o \textit{ClientKeyExchange}.
Assim, o TLS~1.3 adianta a negociação ECDHE e reduz a quantidade total de mensagens necessárias.

\begin{figure} [ht]
    \centering
    \includegraphics[width=1\linewidth]{ClientHello.png}
    \caption{ClientHello}
    \label{fig:chello}
\end{figure}

\begin{figure} [ht]
    \centering
    \includegraphics[width=1\linewidth]{ClientKeyShare.png}
    \caption{ClientHello - KeyShare}
    \label{fig:chello}
\end{figure}

\paragraph*{ServerHello}
O servidor responde enviando:

\begin{itemize}
    \item a \textit{cipher suite} selecionada;
    \item o \textit{Server Random};
    \item sua própria estrutura \textbf{KeyShare} com o valor ECDHE correspondente.
\end{itemize}

Com os valores ECDHE trocados, cliente e servidor já conseguem derivar o \textit{Handshake Secret} via HKDF (HMAC-based Key Derivation Function) - uima função de derivação de chaves que usa HMAC para transformar um segredo inicial em múltiplas chaves criptográficas seguras e independentes.

A partir deste ponto, no TLS~1.3 \textbf{todas as mensagens seguintes passam a ser cifradas}.

\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{ServerHello.png}
    \caption{ServerHello}
    \label{fig:shello}
\end{figure}

No TLS~1.2 essa proteção não ocorria tão cedo: o \textit{ServerHello} era seguido de várias mensagens ainda em texto claro, como \textit{Certificate}, \textit{ServerKeyExchange}, \textit{CertificateRequest} (quando usado) e \textit{ServerHelloDone}.

\subsubsection{Fase 2: Autenticação do Servidor}

Após o \textit{ServerHello}, com a cifração ativada, o servidor envia:

\begin{itemize}
    \item \textbf{EncryptedExtensions}: conjunto de extensões adicionais protegidas por criptografia, indicando parâmetros negociados que não puderam ser enviados em claro no \textit{ServerHello};
    \item \textbf{Certificate}: certificado digital do servidor, contendo sua chave pública e utilizado para comprovar sua identidade ao cliente;
    \item \textbf{CertificateVerify}: prova criptográfica de que o servidor realmente possui a chave privada correspondente ao certificado enviado, assinando dados do handshake com algoritmo de criptografia assimétrica padrão da versão do TLS utilizada (alguma versão do RSA);
    \item \textbf{Finished}: mensagem final de autenticação, contendo um MAC calculado com as chaves derivadas, confirmando a integridade de todo o handshake até esse ponto.
\end{itemize}


Toda essa etapa ocorre em canal cifrado no TLS~1.3. No TLS~1.2, porém, essas mensagens eram transmitidas em texto claro, separando esta parte de autenticação com mensagens adicionais como \textit{ServerHelloDone} e um \textit{CertificateVerify} opcional do cliente. 

\subsubsection{Fase 3: Resposta do Cliente e Finalização da Negociação}

Após validar o certificado e verificar a mensagem \textit{Finished} do servidor, o cliente envia sua própria:

\begin{itemize}
    \item \textbf{Finished}.
\end{itemize}

Com isso, ambos derivam as \textit{application traffic keys} e a comunicação segura começa.

No TLS~1.2 existia uma mensagem a mais neste ponto: o \textit{ChangeCipherSpec}, usada para indicar que as partes passariam a cifrar o tráfego. O TLS~1.3 elimina essa etapa completamente, pois a proteção já é ativada automaticamente após o \textit{ServerHello}.

Após a troca dessas mensagens, o handshake está finalizado e o canal seguro é estabelecido.

\subsection{Criptografia no TLS}

A criptografia no TLS~1.3 baseia-se em:

\begin{itemize}
    \item segredo ECDHE compartilhado (Diffie-Hellman Efêmero);
    \item valores aleatórios (\textit{Client Random} e \textit{Server Random});
    \item segredos derivados pelo HKDF: \textit{Early}, \textit{Handshake} e \textit{Master Secret}.
\end{itemize}

O HKDF (HMAC-based Key Derivation Function) é utilizado de forma encadeada para derivar diversos segredos a partir do segredo ECDHE e dos valores aleatórios trocados entre cliente e servidor. No TLS~1.3, cada fase do handshake utiliza um segredo específico, formando uma hierarquia de chaves:

\begin{itemize}
    \item \textbf{Early Secret}: utilizado em conexões com 0-RTT. Derivado antes mesmo da conclusão do handshake completo, pode proteger dados enviados precocemente pelo cliente. Em conexões normais (sem 0-RTT), ele serve apenas como ponto inicial da cadeia de derivação.
    
    \item \textbf{Handshake Secret}: derivado a partir do segredo ECDHE e do \textit{Early Secret}. Fornece as chaves temporárias que protegem as mensagens de handshake (como \textit{EncryptedExtensions}, \textit{Certificate}, etc.). Essas chaves garantem sigilo e integridade durante a autenticação e a negociação.
    
    \item \textbf{Master Secret}: derivado do \textit{Handshake Secret} após a autenticação do servidor. A partir dele são geradas as chaves finais da sessão (chaves de aplicação), utilizadas para cifrar todo o tráfego após o \textit{Finished}. Essas chaves são diferentes para cliente e servidor e são rotacionadas conforme necessário durante a conexão.
\end{itemize}

Além disso, o segredo ECDHE é efêmero e único para cada handshake, fazendo com que cada sessão gere chaves completamente diferentes, evitando ataques de replay e o reuso de sessões.

\subsubsection{Proteção dos Dados}

Cada bloco transmitido é protegido por algoritmos AEAD, como AES-GCM ou ChaCha20-Poly1305, garantindo:

\begin{itemize}
    \item confidencialidade;
    \item integridade;
    \item autenticação.
\end{itemize}

O TLS~1.2 permitia combinações separadas de cifra e MAC (ex.: AES-CBC + HMAC), o que poderia  resultar em falhas de implementação, como ataques de padding. Diante disso, o TLS~1.3 exige exclusivamente AEAD.

Portanto, podemos concluir que o TLS acrescenta uma camada de segurança ao canal confiável já estabelecido pelo TCP, tornando a comunicação adequada para aplicações sensíveis, como transações bancárias, autenticação e transmissão de informações privadas.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{cript1.png}
    \caption{Texto Cifrado no TLS}
    \label{fig:cript}
\end{figure}

\section{Implementação}

\subsection{Server}

\begin{lstlisting}[caption=Servidor]
class Server:
    def __init__(self, host, port, use_tls):
        self.host = host
        self.port = port
        self.use_tls = use_tls
    
    def start(self):
        os.makedirs(FILE_SAVE_PATH, exist_ok=True) # Ensure the directory for saving files exists
        
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind((self.host, self.port))
        server_socket.listen(5) # Allow up to 5 queued connections

        print(f"Server listening on {self.host}:{self.port} {'with TLS' if self.use_tls else 'without TLS'}")

        context = None
        if self.use_tls:
            context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            context.load_cert_chain(certfile='server.crt', keyfile='server.key')
        try:
            while True:
                conn, addr = server_socket.accept()
                if self.use_tls:
                    conn = context.wrap_socket(conn, server_side=True) # Wrap accepted socket with TLS
                client_thread = threading.Thread(target=self.handle_client, args=(conn, addr)) # Handle each client in a new thread
                client_thread.start()
        except KeyboardInterrupt:
            print("Server shutting down.")
        finally:
            server_socket.close()
    
    def handle_client(self, conn, addr):
        print(f"Connection from {addr} has been established.")
        start_time = time.time()
        total_data_received = 0

        data_chunks = []
        try:
            # First, receive the file size (8 bytes) - ensure we get exactly 8 bytes
            size_data = b''
            while len(size_data) < 8:
                chunk = conn.recv(8 - len(size_data))
                if not chunk:
                    print(f"Connection closed while receiving header from {addr}")
                    return
                size_data += chunk
            
            expected_size = int.from_bytes(size_data, byteorder='big')
            print(f"Expecting {expected_size} bytes from {addr}")
            
            # Now receive exactly that many bytes
            while total_data_received < expected_size:
                remaining = expected_size - total_data_received
                chunk_size = min(BUFFER_SIZE, remaining)
                try:
                    data = conn.recv(chunk_size)
                    if not data:
                        break
                    total_data_received += len(data)
                    data_chunks.append(data)
                except (ConnectionResetError, BrokenPipeError, ssl.SSLError) as recv_error:
                    print(f"Error receiving data from {addr}: {recv_error}")
                    break

            data = b''.join(data_chunks)
            end_time = time.time()
            duration = end_time - start_time

            if total_data_received > 0:
                print(f"Received {total_data_received} bytes from {addr} in {duration:.6f} seconds.")
                #timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                #self.save_received_file(data, f"received_from_{addr[0]}_{addr[1]}_{timestamp}.bin")
            
            # Send acknowledgment
            try:
                ack_message = "File received successfully.".encode('utf-8')
                conn.sendall(ack_message)
            except (ConnectionResetError, BrokenPipeError, ssl.SSLError) as send_error:
                print(f"Error sending acknowledgment to {addr}: {send_error}")

            print(f"Connection from {addr} closed. Received {total_data_received} bytes in {duration:.6f} seconds.")
        except Exception as e:
            print(f"Unexpected error from {addr}: {e}")
        finally:
            conn.close()

\end{lstlisting}

\subsection{Client}

\begin{lstlisting}
class Client:
    def __init__(self, host, port, use_tls):
        self.host = host
        self.port = port
        self.use_tls = use_tls
        self.stats = {'data_size': 0,
                      'transfer_time': 0.0,
                      'average_speed': 0.0,
                      'connection_type': 'TLS' if use_tls else 'TCP',
                      'timestamp': '',}
    
    def connect(self):
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            if self.use_tls:
                context = ssl.create_default_context()
                if DEBUG:
                    context.check_hostname = False
                    context.verify_mode = ssl.CERT_NONE # Disable certificate verification for debugging to accept self-signed certs
                self.sock = context.wrap_socket(self.sock, server_hostname=self.host)

            self.sock.connect((self.host, self.port))
            print(f"Connected to server {self.host}:{self.port} {'with TLS' if self.use_tls else 'without TLS'}.")
            if self.use_tls:
                print(f"Server certificate:\n{self.sock.getpeercert()}")
                print(f"TLS version: {self.sock.version()}")
                print(f"Cipher: {self.sock.cipher()}")
                print(f"Compression: {self.sock.compression()}")
                print(f"Server hostname: {self.sock.server_hostname}")
                print(f"Socket timeout: {self.sock.gettimeout()}")

        except Exception as e:
            print(f"Failed to connect: {e}")
            self.sock = None

    def send_file(self, file_path):
        if not self.sock:
            print("No connection established.")
            return

        try:
            with open(file_path, 'rb') as file:
                data = file.read()
                data_size = len(data)
                
                # Send file size header
                size_header = data_size.to_bytes(8, byteorder='big')
                self.sock.sendall(size_header)
                
                # Measure only the data transfer time (not ACK reception)
                start_time = time.time()
                self.sock.sendall(data)
                end_time = time.time()
                
                # Wait for acknowledgment (but don't include in timing)
                ack = self.sock.recv(1024)
                
                if ack:
                    ack_decoded = ack.decode('utf-8')
                    print(f"Server acknowledged: {ack_decoded}")
                
                duration = end_time - start_time
                average_speed = data_size / duration if duration > 0 else 0

                # Update stats
                self.stats['data_size'] = data_size
                self.stats['transfer_time'] = duration
                self.stats['average_speed'] = average_speed
                self.stats['timestamp'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                print(f"Sent {data_size} bytes in {duration:.6f} seconds. Average speed: {average_speed:.2f} bytes/second.")

                # Log performance
                log_performance(data_size, duration, self.use_tls)

        except IOError as e:
            print(f"Failed to read/send file: {e}")
        finally:
            self.sock.close()
\end{lstlisting}


\section{Resultados e Análise}

O uso do TLS, apesar de essencial para assegurar confidencialidade e integridade, acarreta um custo adicional de desempenho, conhecido como \textit{overhead}. Esse custo resulta diretamente das operações criptográficas realizadas durante a negociação da conexão e na proteção dos dados transmitidos.

Assim, o experimento foi conduzido para comparar o desempenho da transferência de dados usando TCP puro e TLS. Para isso, foi utilizado um arquivo pequeno (\texttt{test\_file.txt}, com 195 bytes) e realizado um conjunto de \textbf{31 execuções} para cada protocolo. Em cada rodada, o script \texttt{run\_performance\_tests.py} estabeleceu a conexão, transferiu o arquivo e registrou automaticamente o tempo total e o \textit{throughput}.

Os resultados finais apresentados são as médias das 31 repetições por protocolo usando uma análise indicada pelo Teorema Central do Limite, o que reduz variações pontuais e permite uma análise mais confiável do impacto do TLS sobre o desempenho.

\begin{table}[H]
    \centering
    \begin{tabular}{l|c|c|c}
 
    \textbf{Métrica} & \textbf{TCP Puro} & \textbf{TLS} & \textbf{Impacto} \\
    \hline
    Tempo Médio & 0.0066s & 0.0099s & \textbf{+50.00\%} \\
    \hline
    Throughput Médio & 43.16 MB/s & 20.05 MB/s & \textbf{-46.45\%} \\
    \end{tabular}
    \label{tab:tabela 1}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{graph_performance_comparison.png}
    \caption{Gráfico de comparação TCP Puro x TLS}
    \label{fig:tempo}
\end{figure}

\subsection{Interpretação do Overhead}

Os resultados mostram que o uso de TLS aumentou o tempo médio de transferência de 0.0066s para 0.0099s. Esse aumento corresponde a um \textbf{Fator de Desaceleração de aproximadamente 0.50x}, indicando que a transmissão protegida levou cerca de 50\% mais tempo que o TCP puro.

Os motivos principais para essa desaceleração são:

\begin{itemize}
\item \textbf{Handshake Inicial}: Antes de enviar qualquer dado, o TLS precisa negociar algoritmos, validar certificado e realizar a troca de chaves (Neste caso, via ECDHE), introduzindo latência adicional.
\item \textbf{Criptografia e Descriptografia}: Cada bloco de dados precisa ser cifrado pelo cliente e decifrado pelo servidor. Esse processamento contínuo, embora rápido em arquivos pequenos, ainda adiciona custo de CPU perceptível.
\item \textbf{Sobrecarga de Protocolo}: Cada registro TLS inclui metadados e um \textit{authentication tag}, aumentando levemente o tamanho transmitido e contribuindo para a queda de vazão.
\end{itemize}

Esses fatores explicam a redução de 46.45\% no throughput, que caiu de 43.16 MB/s (TCP Puro) para 20.05 MB/s (TLS).

\section{Conclusão}

Os experimentos demonstram que o uso de TLS introduz um custo de desempenho mensurável, aumentando o tempo de transferência em cerca de 1.50x e reduzindo o throughput em aproximadamente 50\%. Apesar desse impacto, o TLS permanece indispensável, pois garante confidencialidade, integridade e autenticação — requisitos fundamentais em qualquer comunicação moderna.

Assim, o relatório confirma que existe um trade-off claro entre segurança e desempenho: o TLS adiciona latência e processamento, mas esses custos são plenamente justificáveis frente aos benefícios de proteção dos dados.

\end{document}